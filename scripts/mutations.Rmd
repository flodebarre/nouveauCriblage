---
title: "Mutations"
author: "FD"
output: 
  html_document: 
      code_folding: hide
      toc: TRUE
      toc_float: TRUE
      self_contained: no
editor_options:
  chunk_output_type: console
---

```{r, eval=FALSE}
rm(list = ls()) # I don't care what you think
for(i in dev.list()) dev.off()
setwd("scripts/")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Source of the data:  
<https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/>

# Initializations

```{r}
# Whether to download the data
dlData <- TRUE
```


```{r}
library(RColorBrewer)
colMut <- brewer.pal(n = 8, name = "Dark2")

col484K <- colMut[1]
col484Q <- colMut[2]
col452R <- colMut[3]
colTotCrib <- gray(0)#colMut[8]
colTot <- colMut[7]

col452R.complement <- "#b37570"
```

```{r}
unique.noNA <- function(x){
  unique(x[!is.na(x)])
}
```

# Load data 

## Test data

```{r}
URL_Deps <- "https://www.data.gouv.fr/fr/datasets/r/4d3e5a8b-9649-4c41-86ec-5420eb6b530c"
URL_Regions <- "https://www.data.gouv.fr/fr/datasets/r/5ff0cad6-f150-47ea-a4e0-57e354c1b2a4"
URL_France <- "https://www.data.gouv.fr/fr/datasets/r/848debc4-0e42-4e3b-a176-afc285ed5401"
```


```{r}
# Download files from repo
# Need to use extra option to follow the redirection

if(dlData){
  download.file(URL_France, 
                destfile="../data/muts_France.csv",
                method="curl",
                extra='-L')
  download.file(URL_Regions, 
                destfile="../data/muts_Regions.csv",
                method="curl",
                extra='-L')
  download.file(URL_Deps, 
                destfile="../data/muts_Deps.csv",
                method="curl",
                extra='-L')
}


dat.France <- read.csv("../data/muts_France.csv", sep = ";", stringsAsFactors = FALSE)
dat.Regions <- read.csv("../data/muts_Regions.csv", sep = ";", stringsAsFactors = FALSE)
dat.Deps <- read.csv("../data/muts_Deps.csv", sep = ";", stringsAsFactors = FALSE)

```


## Geographic data

### Regions 

```{r}
# Codes regions
URL <- "https://www.data.gouv.fr/en/datasets/r/34fc7b52-ef11-4ab0-bc16-e1aae5c942e7"
dataFile <- "../data/coderegions.csv"
download.file(URL, dataFile)
codesRegions <- read.csv(dataFile, sep = ",", stringsAsFactors = FALSE)

# Turn into dictionary
regs <- codesRegions$nom_region
names(regs) <- as.character(codesRegions$code_region)

# Add region name
dat.Regions$reg_name <- regs[as.character(dat.Regions$reg)]

unique(dat.Regions$reg_name)
unique(dat.Regions[which(is.na(dat.Regions$reg_name)), "reg"])


```


### Departments

```{r}
# Add name
deps <- read.csv("../data/departement2020.csv", stringsAsFactors = FALSE)
# Turn into dictionnary
dps <- deps$libelle
names(dps) <- as.character(deps$dep)


dat.Deps$departement <- dps[as.character(dat.Deps$dep)]

unique(dat.Deps$departement)

unique(dat.Deps[which(is.na(dat.Deps$departement)), "dep"])

# 977 Saint-Barthélemy, 978 Saint-Martin
```

## Clean data

```{r}
# Format date
dat.France$date1 <- as.Date(substring(dat.France$semaine, 1, 10))
dat.France$date2 <- as.Date(substring(dat.France$semaine, 12, 21))
# Rewrite time as days since beginning of the data
dat.France$time <- dat.France$date2 - min(dat.France$date2)

# Mid-interval date
dat.France$dateMid <- dat.France$date2 - 3
```


```{r}
# Format date
dat.Regions$date1 <- as.Date(substring(dat.Regions$semaine, 1, 10))
dat.Regions$date2 <- as.Date(substring(dat.Regions$semaine, 12, 21))
# Rewrite time as days since beginning of the data
dat.Regions$time <- dat.Regions$date2 - min(dat.Regions$date2)

# Mid-interval date
dat.Regions$dateMid <- dat.Regions$date2 - 3
```


```{r}
# Format date
dat.Deps$date1 <- as.Date(substring(dat.Deps$semaine, 1, 10))
dat.Deps$date2 <- as.Date(substring(dat.Deps$semaine, 12, 21))
# Rewrite time as days since beginning of the data
dat.Deps$time <- dat.Deps$date2 - min(dat.Deps$date2)

# Mid-interval date
dat.Deps$dateMid <- dat.Deps$date2 - 3
```


## Consistency checks 

```{r}

testDat <- function(dat){
  # Check number of genotypied tests
  testTotA <- sum(dat$nb_crib != (dat$nb_A0+ dat$nb_A1))
  testTotB <- sum(dat$nb_crib != (dat$nb_B0+ dat$nb_B1))
  testTotC <- sum(dat$nb_crib != (dat$nb_C0+ dat$nb_C1))
  
  # Test proportions of positive genotyping tests
  # nb of digits in the result varies across datasets
  if(all(dat$tx_A1 == round(dat$tx_A1, 1))){nDigits <- 1}else{nDigits <- 2}
  testA <- sum(dat$tx_A1 != round(dat$nb_A1 / (dat$nb_A0 + dat$nb_A1)*100, nDigits), na.rm = TRUE)
  testB <- sum(dat$tx_B1 != round(dat$nb_B1 / (dat$nb_B0 + dat$nb_B1)*100, nDigits), na.rm = TRUE)
  testC <- sum(dat$tx_C1 != round(dat$nb_C1 / (dat$nb_C0 + dat$nb_C1)*100, nDigits), na.rm = TRUE)
  
  testCrib <- sum(round(dat$tx_crib / 100 * dat$nb_pos) != round(dat$nb_crib))
  
  # Return outcome
  c(nrow(dat), testCrib, testTotA, testTotB, testTotB, testA, testB, testC)
}

testDat(dat.France)
testDat(dat.Regions)
testDat(dat.Deps)
```

# (tmp Extractions)

```{r}
tmp <- dat.Regions[which(dat.Regions$reg_name == "Île-de-France"), ]

# dim(tmp)
write.csv(tmp, file = "../data/extractionIDF.csv", col.names = NULL)
```

# Plots 

## Numbers of tests

```{r}
plotNbCrib <- function(dat, quot = TRUE, addLegend = TRUE, tp = "l", lwd = 1.5){
  # dat: dataset to be plotted
  # quot: boolean to decide whether to plot the daily values (averaged over 7 days) [TRUE], or the sum over the last 7 days [FALSE]
  # addLegend: whether to add plot legend
  # tp: line type
  if(quot){denom <- 7}else{denom <- 1}
  par(las = 1)
  par(mar = c(2, 4, 3, 4))
  plot(as.Date(dat$date2), dat$nb_pos / denom, ylim = c(0, 1.05*max(dat$nb_pos / denom, na.rm = TRUE)), yaxs = "i", 
       type = tp, pch = 16, col = colTot, 
       lwd = lwd, 
       frame.plot = FALSE, 
       xlab = "", ylab = "")
  
  lines(as.Date(dat$date2), dat$nb_crib / denom, type = tp, pch = 16, col = colTotCrib)
  
  if(addLegend){
    legend(x = "topright", legend = c("Nb tests positifs", "Nb tests criblés", "Nb tests interprétables E484K", "Nb tests interprétables E484Q", "Nb tests interprétables L452R"), 
         col = c(colTot, colTotCrib, col484K, col484Q, col452R), 
         #pch = 16, 
         lty = 1, box.col = gray(0, 0), bty = "n", 
         lwd = lwd)
  }
  
  lines(as.Date(dat$date2), (dat$nb_A0 + dat$nb_A1) / denom, type = tp, pch = 16, col = col484K, lwd = lwd)
  lines(as.Date(dat$date2), (dat$nb_B0 + dat$nb_B1) / denom, type = tp, pch = 16, col = col484Q, lwd = lwd)
  lines(as.Date(dat$date2), (dat$nb_C0 + dat$nb_C1) / denom, type = tp, pch = 16, col = col452R, lwd = lwd)
  
  axis(4)
}
```

```{r}
#
plotTauxCrib <- function(dat){
  par(las = 1)
  par(mar = c(2, 4, 3, 4))

  plot(dat$dateMid, dat$tx_crib, ylim = c(0, 100), type = "l", lwd = 3, col = gray(0.3), frame.plot = FALSE, 
       xlab = "", ylab = "", yaxs = "i")
  axis(4)
}

```



```{r NbCribFrance}
plotNbCrib(dat.France)
title(main = "France")
```

```{r TxCribFrance}
plotTauxCrib(dat.France[dat.France$dateMid >= "2021-11-15", ])
title(main = "France")

```


```{r NbCribRegions}
# Plot all regions in single plots
# for(reg in unique.noNA(dat.Regions$reg_name)){
#   dat <- dat.Regions[dat.Regions$reg_name == reg, ]
#   plotNbCrib(dat, addLegend = FALSE)
#   title(main = reg)
# }
```


```{r}
# Function to plot one region
plotReg <- function(reg){
  dat <- dat.Regions[dat.Regions$reg_name == reg, ]
  plotNbCrib(dat, addLegend = FALSE)
  title(main = reg)
}

# Function to plot one region
plotRegTx <- function(reg){
  dat <- dat.Regions[dat.Regions$reg_name == reg & dat.Regions$dateMid > "2021-11-01", ]
  plotTauxCrib(dat)
  title(main = reg)
}

#[1] "Auvergne-Rhône-Alpes"       "Hauts-de-France"            "Provence-Alpes-Côte d'Azur" "Grand Est"                 
# [5] "Occitanie"                  "Normandie"                  "Nouvelle-Aquitaine"         "Centre-Val de Loire"       
# [9] "Corse"                      "Bourgogne-Franche-Comté"    "Bretagne"                   "Pays de la Loire"          
#[13] "Île-de-France"              "Guadeloupe"                 "Martinique"                 "Guyane"                 
#[17] "La Réunion"                 "Mayotte" 
```

```{r figRegionsMapNBCriblage, fig.width=10, fig.height=10}

layout(matrix(1:15, ncol = 3, byrow = TRUE))

# 1 Plot legend
par(mar = c(0, 0, 0, 0))
plot(0, 0, xlab = "", ylab = "", type = "n", axes = FALSE, xlim = c(-0.2, 1), ylim = c(-1, 0.5))
legend(x = 0, y = 0, legend = c("Nb tests positifs", "Nb tests criblés", "Nb tests interprétables E484K", "Nb tests interprétables E484Q", "Nb tests interprétables L452R"), 
         col = c(colTot, colTotCrib, col484K, col484Q, col452R), 
         #pch = 16, 
         lty = 1, box.col = gray(0, 0), bty = "n", cex = 1)

# 2 HDF
plotReg("Hauts-de-France")

# 3 Plot credits
par(mar = c(0, 0, 0, 0))
plot(0, 0, xlab = "", ylab = "", type = "n", axes = FALSE, xlim = c(-0.1, 1), ylim = c(-1, 1))
text(0, 0, "@flodebarre 

Data:
https://www.data.gouv.fr/fr/datasets/
donnees-de-laboratoires-pour-le-
depistage-indicateurs-sur-les-mutations/

Code: https://github.com/flodebarre/
nouveauCriblage/blob/main/scripts/mutations.Rmd
", adj = 0, cex = 0.8, family = "mono")

# 4 NOR
plotReg("Normandie")

# 5 IDF
plotReg("Île-de-France")

# 6 GE
plotReg("Grand Est")

# 7 BRE
plotReg("Bretagne")

# 8 CVL
plotReg("Centre-Val de Loire")

# 9 BFC
plotReg("Bourgogne-Franche-Comté")

# 10 PDL
plotReg("Pays de la Loire")

# 11 ARA
plotReg("Auvergne-Rhône-Alpes")

# 12 PACA
plotReg("Provence-Alpes-Côte d'Azur")

# 13 NAQ
plotReg("Nouvelle-Aquitaine")

# 14 OCC
plotReg("Occitanie")

# 15 COR
plotReg("Corse")
#[1] "Auvergne-Rhône-Alpes"       "Hauts-de-France"            "Provence-Alpes-Côte d'Azur" "Grand Est"                 
# [5] "Occitanie"                  "Normandie"                  "Nouvelle-Aquitaine"         "Centre-Val de Loire"       
# [9] "Corse"                      "Bourgogne-Franche-Comté"    "Bretagne"                   "Pays de la Loire"  

```

```{r figRegionsMapTauxCriblage, fig.width=10, fig.height=10}

layout(matrix(1:15, ncol = 3, byrow = TRUE))

# 1 Plot legend
par(mar = c(0, 0, 0, 0))
plot(0, 0, xlab = "", ylab = "", type = "n", axes = FALSE, xlim = c(-0.2, 1), ylim = c(-1, 0.5))
text(0, 0, "Pourcentage de tests criblés", adj = c(0, 0), cex = 1.3)
text(0, 0, "(les données publiques sont déjà lissées)", adj = c(0, 2))
# 2 HDF
plotRegTx("Hauts-de-France")

# 3 Plot credits
par(mar = c(0, 0, 0, 0))
plot(0, 0, xlab = "", ylab = "", type = "n", axes = FALSE, xlim = c(-0.1, 1), ylim = c(-1, 1))
text(0, 0, "@flodebarre 

Data:
https://www.data.gouv.fr/fr/datasets/
donnees-de-laboratoires-pour-le-
depistage-indicateurs-sur-les-mutations/

Code: https://github.com/flodebarre/
nouveauCriblage/blob/main/scripts/mutations.Rmd
", adj = 0, cex = 0.8, family = "mono")

# 4 NOR
plotRegTx("Normandie")

# 5 IDF
plotRegTx("Île-de-France")

# 6 GE
plotRegTx("Grand Est")

# 7 BRE
plotRegTx("Bretagne")

# 8 CVL
plotRegTx("Centre-Val de Loire")

# 9 BFC
plotRegTx("Bourgogne-Franche-Comté")

# 10 PDL
plotRegTx("Pays de la Loire")

# 11 ARA
plotRegTx("Auvergne-Rhône-Alpes")

# 12 PACA
plotRegTx("Provence-Alpes-Côte d'Azur")

# 13 NAQ
plotRegTx("Nouvelle-Aquitaine")

# 14 OCC
plotRegTx("Occitanie")

# 15 COR
plotRegTx("Corse")
#[1] "Auvergne-Rhône-Alpes"       "Hauts-de-France"            "Provence-Alpes-Côte d'Azur" "Grand Est"                 
# [5] "Occitanie"                  "Normandie"                  "Nouvelle-Aquitaine"         "Centre-Val de Loire"       
# [9] "Corse"                      "Bourgogne-Franche-Comté"    "Bretagne"                   "Pays de la Loire"  

```



## Proportions / Nb tests

```{r}
plotMut <- function(time, test0, test1, col, thetit, ymax = 1, quot = TRUE){
  # dat: dataset to be plotted
  # quot: boolean to decide whether to plot the daily values (averaged over 7 days) [TRUE], or the sum over the last 7 days [FALSE]
  
  if(quot){denom <- 7}else{denom <- 1}
  n <- (test1 + test0) / denom
  p <- test1 / (test1 + test0)
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) 
  # Remove points for which the itv cannot be computed
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]

  par(mar = c(5, 4, 4, 4))
  par(las = 1)
  plot(as.Date(time), p, ylim = c(0, ymax), frame.plot = FALSE, 
     xlab = "", ylab = "p", yaxs = "i", xaxs = "i", 
     type = "l", col = col, pch = 16)
mtext("  Parmi les n(t) tests interprétables recherchant la mutation
  Intervalle de confiance binomial sur ce nombre de tests n(t)", side = 3, cex = 0.6, adj = 0, line = -1)
mtext("date", line = 2, side = 1)  
  axis(4)
  xx <- base::as.Date(time)[keepPts]
  # Add graduation
  for(i in seq(0, 1, by = 0.1)){
    abline(h = i, col = gray(0.9), lwd = 1.1)
  }
  for(i in seq(0.05, 0.95, by = 0.1)){
    abline(h = i, col = gray(0.9), lwd = 0.8)
  }
  
  polygon(x = c(xx, rev(xx), xx[1]), y = c(pp + deltaItv, rev(pp - deltaItv), (pp + deltaItv)[1]), border = NA, col = adjustcolor(col, alpha.f = 0.3))
  
  mtext("Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
Code : https://github.com/flodebarre/nouveauCriblage", side = 1, line = 3.5, cex = 0.7, col = gray(0.5), adj = 0)

  title(main = thetit)
  print(p[length(p)])
}
```


```{r}
plotMut0 <- function(time, test0, test1, col, thetit, ymin = 10^-6, ymax = 1 - 10^-6, quot = TRUE, scale = "logit", addNotes = TRUE, addDeliss = FALSE, test0dl, test1dl, coldl = "#FFD390"){
  # -- here showing n0/(n0+n1) --
  # time: vector of values of times of sample collection
  # test0: vector of numbers of tests with value 0
  # test1: vector of numbers of tests with value 1
  # col: color used for the plot
  # thetit: title of the plot
  # ymin: min y value
  # ymax: max y value
  # quot: (quotidien) boolean to decide whether to plot the daily values (averaged over 7 days) [TRUE], or the sum over the last 7 days [FALSE]
  # scale: "logit" or "linear"
  
  if(quot){denom <- 7}else{denom <- 1}
  n <- (test1 + test0) / denom
  p <- test0 / (test1 + test0)
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) 
  # Remove points for which the interval cannot be computed
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]
  
  if(addDeliss){
    ndl <- (test1dl + test0dl) / denom
    pdl <- test0dl / (test0dl + test1dl)
    deltaItvdl <- 1.96 * sqrt(pdl * (1-pdl) / ndl)
    keepPtsdl <- !is.na(deltaItvdl) 
    # Remove points for which the interval cannot be computed
    deltaItvdl <- deltaItvdl[keepPtsdl]
    ppdl <- pdl[keepPtsdl]
  }

  # Compute new values on the new scale
  changeScale <- function(p, confInt = FALSE){
    out <- NA # Initialize output, have NA if scale not properly written
    if(scale == "logit"){
      # Make sure that p is between 0 and 1 (can be different with conf int)
      p[p < ymin] <- max(0, 0.5*ymin)
      p[p > ymax] <- 2*ymax
      
      out <- log(p /(1-p)) # Logit scale
    }
    if(scale == "linear"){
      out <- p # Linear scale, no change
    }
    out
  }

  par(mar = c(5, 4, 4, 4))
  par(las = 1, mgp = c(2.5, 0.3, 0), tck = -0.01)
  
  plot(as.Date(time), changeScale(p), 
       ylim = c(changeScale(ymin), changeScale(ymax)), frame.plot = FALSE, 
       xlab = "", ylab = "", 
       type = "p", col = col, pch = 16, 
       axes = FALSE)
  
  if(addNotes){
    text(x = as.Date(time[1]), y = changeScale(ymax), labels = paste0("  Données jusqu'au ", format(as.Date(max(time)), "%d/%m/%Y"), 
  "

  Proportion p0 = C0 / (C0 + C1) parmi les tests interprétables recherchant la mutation
  Intervalle de confiance binomial sur ce nombre de tests interprétables  
  
  Attention : 
  - Les données publiques sont données partagées déjà lissées sur 7j, ce qui atténue le signal
  - Le nombre de résultats de criblage rendus publics est actuellement faible"), cex = 0.7, adj = c(0, 1))
  }

  
  # Label of the horizontal axis
  #mtext("date", line = 2, side = 1)  

  xx <- base::as.Date(time)[keepPts]
  
  # Add confidence interval as arrows
  arrows(x0 = xx, 
         x1 = xx, 
         y0 = changeScale(pp - deltaItv), 
         y1 = changeScale(pp + deltaItv), 
         code = 0, 
         lwd = 3, 
         col = adjustcolor(col, alpha.f = 0.5), 
         lend = 1)

  if(scale == "linear"){
    # Add graduation
    for(i in seq(0, 1, by = 0.1)){
      abline(h = i, col = gray(0.9), lwd = 1.1)
    }
    for(i in seq(0.05, 0.95, by = 0.1)){
      abline(h = i, col = gray(0.9), lwd = 0.8)
    }
  }
  
  
  # If add "delissees" data
  if(addDeliss){
    points(as.Date(time), changeScale(pdl), type = "p", col = coldl, pch = 16)

    xxdl <- base::as.Date(time)[keepPtsdl]

    # Add confidence interval as arrows
    arrows(x0 = xxdl, 
         x1 = xxdl, 
         y0 = changeScale(ppdl - deltaItvdl), 
         y1 = changeScale(ppdl + deltaItvdl), 
         code = 0, 
         lwd = 3, 
         col = adjustcolor(coldl, alpha.f = 0.5), 
         lend = 1)
  }
  

  if(addNotes){
  # Add note about data and code provenance
  mtext("Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
Code : https://github.com/flodebarre/nouveauCriblage/blob/main/scripts/mutations.Rmd", side = 1, line = 3.5, cex = 0.5, col = gray(0.5), adj = 0, family = "mono")
    
    par(xpd = TRUE)
    legend("topleft", col = c(col, coldl), pch = 16, legend = c("Données publiques, lissées", "Données délissées"), 
           bty = "n", horiz = TRUE, cex = 0.9, inset = c(0, -0.05))
    par(xpd = FALSE)
  }

  # Axes: 
  # horizontal
  xxl <- seq(as.Date(min(time)), as.Date(max(time)), by = "day")
  axis(1, at = xxl, 
       labels = format(seq(as.Date(min(time)), as.Date(max(time)), by = "day"), "%d/%m"), 
       las = 2, 
       cex.axis = 0.7)
  
  # Vertical axes
  if(scale == "linear"){
    axis(2)
    axis(4)
  }
  if(scale == "logit"){
    yvalues <- c(0.999, 0.99, 0.9, 0.75, 0.5, 0.25, 0.1, 0.05, 0.025, 0.01, 0.001)
    axis(2, at = changeScale(yvalues), labels = yvalues)
    axis(4, at = changeScale(yvalues), labels = yvalues)
  }
  
  if(scale == "linear"){
    mtext(expression("p"[0]), side = 2, las = 0, line = 2.5)
  }
  if(scale == "logit"){
    mtext(expression(paste("p"[0], ", logit scale")), side = 2, las = 0, line = 2.5)
  }
  
  title(main = thetit)
  print(p[length(p)])
}

layout(1)
ix <- which(dat.France$date2 >= "2021-11-01")
plotMut0(dat.France[ix, "date2"], dat.France[ix, "nb_C0"], dat.France[ix, "nb_C1"], col = col452R, thetit = "Proportion des tests criblés sans la mutation L452R, France", ymin = 10^-2, ymax = 0.6)


#plotRegC0("Île-de-France", addNotes = TRUE)

```

```{r funcplotCaseMut}
plotCaseMut <- function(time, test0, test1, col, thetit, ymax = 1, quot = TRUE){
  # dat: dataset to be plotted
  # quot: boolean to decide whether to plot the daily values (averaged over 7 days) [TRUE], or the sum over the last 7 days [FALSE]
  
  if(quot){denom <- 7}else{denom <- 1}
  n <- (test1 + test0) / denom
  p <- test1 / (test1 + test0)
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) 
  # Remove points for which the itv cannot be computed
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]
  nn <- n[keepPts]

  par(mar = c(5, 4, 4, 4))
  par(las = 1)
  ymax <- 1.05 * max(pp*nn + nn*deltaItv, na.rm = TRUE)
  plot(as.Date(time), p * n, ylim = c(0, ymax), frame.plot = FALSE, 
     xlab = "", ylab = "n", yaxs = "i", xaxs = "i", 
     type = "o", col = col, pch = 16)
mtext("  Parmi les n(t) = C0(t) + C1(t) tests interprétables recherchant la mutation
  Intervalle de confiance binomial sur ce nombre de tests n(t)
  
  Attention : les données publiques sont données partagées déjà lissées sur 7j", side = 3, cex = 0.7, adj = 0, line = -1)
mtext("date", line = 2, side = 1) 
  axis(2, at = seq(0, 1, by = 0.1))
  axis(4, at = seq(0, 1, by = 0.1))
  xx <- base::as.Date(time)[keepPts]
  polygon(x = c(xx, rev(xx), xx[1]), y = c(nn*pp + nn*deltaItv, rev(nn*pp - nn*deltaItv), (nn*pp + nn*deltaItv)[1]), border = NA, col = adjustcolor(col, alpha.f = 0.3))
  
  mtext("Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
Code : https://github.com/flodebarre/nouveauCriblage", side = 1, line = 3.5, cex = 0.7, col = gray(0.5), adj = 0)

  title(main = thetit)
}
```


### France 

```{r}
plotMut(dat.France$date2, dat.France$nb_A0, dat.France$nb_A1, col = col484K, thetit = "Proportion of cases with \nE484K, France", ymax = 0.3)
plotMut(dat.France$date2, dat.France$nb_B0, dat.France$nb_B1, col = col484Q, thetit = "Proportion of cases with \nE484Q, France", ymax = 0.3)
plotMut(dat.France$date2, dat.France$nb_C0, dat.France$nb_C1, col = col452R, thetit = "L452R, France")
```

```{r}
plotCaseMut(dat.France$date2, dat.France$nb_A0, dat.France$nb_A1, col = col484K, thetit = "E484K, France")
plotCaseMut(dat.France$date2, dat.France$nb_B0, dat.France$nb_B1, col = col484Q, thetit = "E484Q, France")
plotCaseMut(dat.France$date2, dat.France$nb_C0, dat.France$nb_C1, col = col452R, thetit = "L452R, France")
```


### Regions 

```{r regionsPlot, eval = FALSE}
for(reg in unique.noNA(dat.Regions$reg_name)){
  dat <- dat.Regions[dat.Regions$reg_name == reg, ]
  plotMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", reg), ymax = 1)
}

```

```{r}
# Source function to turn back into raw data 
source("delissage.R")
```



```{r figRegionsMapPropC0, fig.width=10, fig.height=15}

# Function to plot one region
# We set et all parameters here
plotRegC0 <- function(reg, xmin = "2021-11-01", ...){
  dat <- dat.Regions[which(dat.Regions$reg_name == reg & dat.Regions$date2 >= xmin), ]
  
  # Delissage
  tmp <- delissage(reg)
  tmp <- tmp[which(tmp$date2 >= xmin), ]
  
  # Export
  regNB <- unique(dat$reg)
  write.csv(tmp, file = paste0("../data/deliss_reg-", regNB, ".csv"))
  
  plotMut0(dat$date2, dat$nb_C0, dat$nb_C1, col = col452R, thetit = "", 
           ymin = 0.5*10^-2, ymax = 0.5, 
           addDeliss = TRUE, 
           test0dl = tmp$nb_C0_dl, 
           test1dl = tmp$nb_C1_dl, ...)
#ix <- which(dat.France$date2 > "2021-11-01")
#plotMut0(dat.France[ix, "date2"], dat.France[ix, "nb_C0"], dat.France[ix, "nb_C1"], col = col452R, thetit = "L452R, France", ymin = 10^-2, ymax = 0.6)
  title(main = reg)
}


#
#ix <- which(dat.France$date2 > "2021-11-01")
#plotMut0(dat.France[ix, "date2"], dat.France[ix, "nb_C0"], dat.France[ix, "nb_C1"], col = col452R, thetit = "L452R, France", ymin = 10^-2, ymax = 0.6)

layout(matrix(1:15, ncol = 3, byrow = TRUE))

# 1 Plot legend
par(mar = c(0, 0, 0, 0))
plot(0, 0, xlab = "", ylab = "", type = "n", axes = FALSE, xlim = c(-0.2, 1), ylim = c(-1, 0.5))
# legend(x = 0, y = 0, legend = c("Nb tests positifs", "Nb tests criblés", "Nb tests interprétables E484K", "Nb tests interprétables E484Q", "Nb tests interprétables L452R"), 
#          col = c(colTot, colTotCrib, col484K, col484Q, col452R), 
#          #pch = 16, 
#          lty = 1, box.col = gray(0, 0), bty = "n", cex = 1)

# 2 HDF
#layout(1)
plotRegC0("Hauts-de-France")


# 3 Plot credits
par(mar = c(0, 0, 0, 0))
plot(0, 0, xlab = "", ylab = "", type = "n", axes = FALSE, xlim = c(-0.1, 1), ylim = c(-1, 1))
text(0, 0, "@flodebarre 

Data:
https://www.data.gouv.fr/fr/datasets/
donnees-de-laboratoires-pour-le-
depistage-indicateurs-sur-les-mutations/

Code: https://github.com/flodebarre/
nouveauCriblage/blob/main/scripts/mutations.Rmd
", adj = 0, cex = 0.8, family = "mono")

# 4 NOR
plotRegC0("Normandie")

# 5 IDF
# 
#layout(1)
plotRegC0("Île-de-France")

# 6 GE
plotRegC0("Grand Est")

# 7 BRE
plotRegC0("Bretagne")

# 8 CVL
plotRegC0("Centre-Val de Loire")

# 9 BFC
plotRegC0("Bourgogne-Franche-Comté")

# 10 PDL
plotRegC0("Pays de la Loire")

# 11 ARA
plotRegC0("Auvergne-Rhône-Alpes")

# 12 PACA
plotRegC0("Provence-Alpes-Côte d'Azur")

# 13 NAQ
plotRegC0("Nouvelle-Aquitaine")

# 14 OCC
plotRegC0("Occitanie")

# 15 COR
plotRegC0("Corse")
```

```{r IDF}
plotRegC0("Île-de-France")
```

```{r predict}

source("projections.R")
```


### Departements

```{r}
ymax <- max(1, 1.05*max(dat.Deps$nb_C1 / (dat.Deps$nb_C1 + dat.Deps$nb_C0), na.rm = TRUE))
```

```{r eval = FALSE}
for(dep in sort(unique.noNA(dat.Deps$departement))){
  dat <- dat.Deps[dat.Deps$departement == dep, ]
  plotMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", dep), ymax = ymax)
}
```

```{r eval = FALSE}
ymax <- max(1, 1.05*max(dat.Deps$nb_B1 / (dat.Deps$nb_B1 + dat.Deps$nb_B0), na.rm = TRUE))
for(dep in sort(unique.noNA(dat.Deps$departement))){
  dat <- dat.Deps[dat.Deps$departement == dep, ]
  plotMut(time = dat$date2, test0 = dat$nb_B0, test1 = dat$nb_B1, col = col484Q, thetit = paste0("E484Q, ", dep), ymax = ymax)
}
```

```{r}
dep <- "Val-de-Marne"
dat <- dat.Deps[which(dat.Deps$departement == dep & dat.Deps$date2 >= "2021-11-01"), ]
  plotCaseMut(time = dat$date2, test0 = dat$nb_B0, test1 = dat$nb_B1, col = col484Q, thetit = paste0("E484Q, ", dep))
  plotCaseMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", dep))
  plotMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", dep))
  plotMut0(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", dep), ymin = 0.001, ymax = 0.5)
  plotCaseMut(time = dat$date2, test0 = dat$nb_A0, test1 = dat$nb_A1, col = col484K, thetit = paste0("E484K, ", dep))
```

## Geographic
### L452R 

Source idea map: [Le Monde map](https://www.lemonde.fr/les-decodeurs/article/2020/05/05/coronavirus-age-mortalite-departements-pays-suivez-l-evolution-de-l-epidemie-en-cartes-et-graphiques_6038751_4355770.html) [| archived](https://archive.is/eJ68m)

```{r}
thrp <- 0.15
thrntot <- 30

drawRec <- function(depDat, x, y, dxy, col = col452R, thr.p = thrp, thr.n = thrntot/7, colMaj = col452R.complement){
  # depDat: dataset for this departement
  # x: x position of the bottom left corner
  # y: y position of the bottom left corner
  # dxy: rectangle size c(dx, dy)
  # col: main color
  # thr.p: threshold to plot criblage data, minimum proportion of cases
  # thr.n: threshold in terms of number of tests done
  
  relTime <- as.numeric(depDat$time)/max(as.numeric(depDat$time))
  test0 <- depDat$nb_C0
  test1 <- depDat$nb_C1
  
  denom <- 7
  n <- (test1 + test0) / denom
  p <- test1 / (test1 + test0)
  
  scale.xy <- function(z, z1, z2, zmax = 1){
    # z has to be between 0 and 1
    stopifnot(z >= 0 | z <= 1)
    z1 + (z2 - z1) * z/zmax
  }
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) & (depDat$tx_crib/100 >= thr.p) & (n >= thr.n)
  
  if(any(keepPts)){
      # Remove points for which the itv cannot be computed
  # and point with not enough criblage
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]
  
  # Color depends on whether main mutation
  if(pp[length(pp)] > 0.5){
    thecol <- colMaj
  }else{
      thecol <- col
  }

  lines(scale.xy(relTime[keepPts], x, x + dxy[1]), scale.xy(pp, y, y + dxy[2]), type = "o", col = thecol, pch = 16, cex = 0.2, lwd = 0.7)
  
  xx <- relTime[keepPts]
  
  polygon(x = scale.xy(c(xx, rev(xx), xx[1]), x, x + dxy[1]), y = scale.xy(c(sapply(pp + deltaItv, min, 1), 
                                                                             sapply(rev(pp - deltaItv), max, 0), 
                                                                             sapply((pp + deltaItv)[1], min, 1)), y, y + dxy[2]), border = NA, col = adjustcolor(thecol, alpha.f = 0.3))
  }
  
}
```

```{r figMapDepL452R, fig.width = 7, fig.height = 9}
geog <- read.csv("../data/position_deps.csv", header = FALSE)
names(geog) <- c("x", "y", "dep", "shortName")
rr <- 2 # Rounding factor

d1 <- c(5.367367157581877, 1.008996513422371)
d2 <- c(6.203498009030808, 1.7266142092327605)
dd <- d2 - d1
ddr <- round(dd,rr)

par(mar = rep(0.2, 4) + c(2, 0, 2, 0))
# Initialize plot with rect positions
plot(c(round(geog$x, rr), round(geog$x, rr) + ddr[1]), c(round(geog$y, rr), round(geog$y, rr) + ddr[2]), type = "n", asp = 1, axes = FALSE, xlab = "", ylab = "")

# Add titles of the plots
text(x = round(geog$x, rr) + ddr[1]/2, y = round(geog$y, rr) + ddr[2], labels = paste0(geog$shortName, "(", geog$dep, ")"), bg = "white", adj = c(0.5, -0.4), cex = 0.45)

for(i in seq_len(nrow(geog))){
  # Draw rectangle
  rect(xleft = round(geog[i, "x"], rr), ybottom = round(geog[i, "y"], rr), xright = round(geog[i, "x"], rr) + ddr[1], ytop = round(geog[i, "y"], rr) + ddr[2], lwd = 0.5, border = gray(0.6))
  
  # Select departement data
  depDat <- dat.Deps[which(dat.Deps$dep == geog[i, "dep"]), ]
  
  # Horizontal line for 0.5
  lines(c(round(geog[i, "x"], rr), round(geog[i, "x"], rr) + ddr[1]), rep(round(geog[i, "y"], rr) + ddr[2]/2, 2), lty = 1, col = gray(0.6), lwd = 0.5)
  
  # Draw curve
  drawRec(depDat, x = round(geog[i, "x"], rr), y = round(geog[i, "y"], rr), dxy = ddr, col = col452R)

#    readline(prompt="Press [enter] to continue")

}


#drawRec(depDat, x = 5.73820184045573, y = 7.01837788404748, dxy = ddr, col = col452R)

minDay <- format(min(dat.Deps$date2), "%d %b")
maxDay <- format(max(dat.Deps$date2), "%d %b")


xP <- 1.34031283936975
yP <- 15.0106959818622
cexLeg <- 0.45
text(x = xP, y = yP, adj = c(1, 0), labels = "0% ", cex = 0.4)
text(x = xP, y = yP + ddr[2], adj = c(1, 0.5), labels = "100% ", cex = cexLeg)

text(x = c(xP, xP + ddr[1]), y = c(yP, yP), adj = c(0.5, 1.5), labels = c(minDay, maxDay), cex = cexLeg)

title("Proportion de L452R")

  mtext("  @flodebarre
  Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
  Code : https://github.com/flodebarre/nouveauCriblage
  Idée carte : Les Decodeurs, Le Monde https://tinyurl.com/carteFRDecLM", side = 1, line = 1, cex = 0.6, col = gray(0.5), adj = 0)
  
cexLegend <- 0.6
legend("topright", legend = c("Proportion L452R, < 50% le dernier jour", "≥ 50% le dernier jour"), cex = cexLegend, bty = "n", col = c(col452R, col452R.complement), lty = 1, pch = 16)
legend("topright", legend = c("", paste0("Données tracées si au moins ", 100*thrp, "% des cas criblés
et au moins ", thrntot, " criblages sur la semaine. 
Itv confiance sur nb crib. moyen 7 derniers jours.")), cex = cexLegend, bty = "n")
```

### Absence L452R 

Source idea map: [Le Monde map](https://www.lemonde.fr/les-decodeurs/article/2020/05/05/coronavirus-age-mortalite-departements-pays-suivez-l-evolution-de-l-epidemie-en-cartes-et-graphiques_6038751_4355770.html) [| archived](https://archive.is/eJ68m)

```{r}
thrp <- 0.125
thrntot <- 30

drawRec0 <- function(depDat, x, y, dxy, col = col452R, thr.p = thrp, thr.n = thrntot/7, colMaj = col452R.complement, scale = "logit", ymin = 1*10^(-3), ymax = 0.5, yvals = c(0.001, 0.01, 0.1, 0.5), ylabels = FALSE){
  # depDat: dataset for this departement
  # x: x position of the bottom left corner
  # y: y position of the bottom left corner
  # dxy: rectangle size c(dx, dy)
  # col: main color
  # thr.p: threshold to plot criblage data, minimum proportion of cases
  # thr.n: threshold in terms of number of tests done
  # scale: type of scale (logit or linear)
  # ymin: minimum y value (natural scale)
  # ymax: maximum y value (natural scale)
  # yvals: values of the horizontal lines
  # ylabels: whether to add ylines labels
  
  relTime <- (as.numeric(depDat$time) - min(as.numeric(depDat$time)))/(max(as.numeric(depDat$time)) - min(as.numeric(depDat$time)))
  test0 <- depDat$nb_C0
  test1 <- depDat$nb_C1
  
  denom <- 7
  n <- (test1 + test0) / denom
  p <- test0 / (test1 + test0)
  
  scale.xy <- function(yv, z1, z2, zmin = 0, zmax = 1){
    # Put y on the (0, 1) scale
    z <- (yv - zmin)/(zmax - zmin)
    # z is between 0 and 1 ; can go beyond with the confidence interval -> crop
    z[z < 0] <- 0
    z[z > 1] <- 1
    # Rescale z on the z1, z2 scale
    z1 + (z2 - z1) * z
  }
  
  # Compute new values on the new scale
  chgScale <- function(Z){
    out <- NA # Initialize output, have NA if scale not properly written
    if(scale == "logit"){
#      print("begin")
#      print(Z)
      # Crop values, can be outside of (0, 1) when confidence interval
      pf <- Z
#      print(pf)
#      cat("lower than ymin", pf[pf < ymin], "\n")
#      cat("greater than ymax", pf[pf > ymax])
      pf[pf < ymin] <- ymin
      pf[pf > ymax] <- ymax
#      print(pf)
      # Compute logit
      out <- log(pf /(1-pf)) # Logit scale
#      print("coucou1")
    }
    if(scale == "linear"){
      out <- p # Linear scale, no change
    }
    out
  }

  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) & (depDat$tx_crib/100 >= thr.p) & (n >= thr.n)
  
  if(any(keepPts)){
  #  print("coucou")
      
  # Remove points for which the itv cannot be computed
  # and point with not enough criblage
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]
  rT <- relTime[keepPts]
  
  # Get confidence interval values
  itvm <- pp - deltaItv
  itvM <- pp + deltaItv
  
  # Crop confidence interval values to the plot range
  
  # Color depends on whether main mutation
  if(pp[length(pp)] > 0.5){
    thecol <- colMaj
  }else{
    thecol <- col
  }

#print(scale.xy(rT, x, x + dxy[1]))
#print(pp)
#print(pp - deltaItv)
#print(chgScale(pp - deltaItv))
#print(chgScale)
#print(scale.xy(chgScale(pp - deltaItv), y, y + dxy[2], zmin = chgScale(ymin), zmax = chgScale(ymax)))

  arrows(x0 = scale.xy(rT, x, x + dxy[1]), 
         x1 = scale.xy(rT, x, x + dxy[1]), 
         y0 = scale.xy(chgScale(pp - deltaItv), y, y + dxy[2], zmin = chgScale(ymin), zmax = chgScale(ymax)), 
         y1 = scale.xy(chgScale(pp + deltaItv), y, y + dxy[2], zmin = chgScale(ymin), zmax = chgScale(ymax)), 
         code = 0, 
         lwd = 1, 
         col = adjustcolor(thecol, alpha.f = 0.5), 
         lend = 1)
  
  # Horizontal lines at specific values
  nh <- length(yvals)
  arrows(x0 = scale.xy(rep(0, nh), x, x + dxy[1]), 
         x1 = scale.xy(rep(1, nh), x, x + dxy[1]), 
         y0 = scale.xy(chgScale(yvals), y, y + dxy[2], zmin = chgScale(ymin), zmax = chgScale(ymax)), 
         y1 = scale.xy(chgScale(yvals), y, y + dxy[2], zmin = chgScale(ymin), zmax = chgScale(ymax)), 
         col = gray(0.8), 
         lend = 1, 
         code = 0, 
         lwd= 0.8
         )
  # Add labels
  if(ylabels){
    dxx <- 0.1
    text(x = scale.xy(rep(max(rT), nh), x + dxx, x + dxy[1] + dxx), 
         y = scale.xy(chgScale(yvals), y, y + dxy[2], zmin = chgScale(ymin), zmax = chgScale(ymax)), 
         labels = yvals, 
         adj = c(0, 0.5), 
         cex = 0.45)
  }
  
  
#  print(pp)
#  print(chgScale(pp))
#  print(chgScale(ymin))
#  print(chgScale(ymax))

    points(scale.xy(rT, x, x + dxy[1]), 
         scale.xy(yv = chgScale(pp), y, y + dxy[2], zmin = chgScale(ymin), zmax = chgScale(ymax)), 
         type = "p", col = thecol, pch = 16, cex = 0.2, lwd = 0.7)
  
  }
}

#  drawRec0(depDat, x = round(geog[i, "x"], rr), y = round(geog[i, "y"], rr), dxy = ddr, col = col452R)

```

```{r figMapDepAbsL452R, fig.width = 7, fig.height = 9}
geog <- read.csv("../data/position_deps.csv", header = FALSE)
names(geog) <- c("x", "y", "dep", "shortName")
rr <- 2 # Rounding factor

d1 <- c(5.367367157581877, 1.008996513422371)
d2 <- c(6.203498009030808, 1.7266142092327605)
dd <- d2 - d1
ddr <- round(dd,rr)

initDate <- "2021-12-01"
ymin <- 1*10^(-3)
ymax <- 0.5

par(mar = rep(0.2, 4) + c(2, 0, 2, 0))
# Initialize plot with rect positions
plot(c(round(geog$x, rr), round(geog$x, rr) + ddr[1]), c(round(geog$y, rr), round(geog$y, rr) + ddr[2]), type = "n", asp = 1, axes = FALSE, xlab = "", ylab = "")

# Add titles of the plots
text(x = round(geog$x, rr) + ddr[1]/2, y = round(geog$y, rr) + ddr[2], labels = paste0(geog$shortName, "(", geog$dep, ")"), bg = "white", adj = c(0.5, -0.4), cex = 0.45)

for(i in seq_len(nrow(geog))){
  # Draw rectangle
  rect(xleft = round(geog[i, "x"], rr), ybottom = round(geog[i, "y"], rr), xright = round(geog[i, "x"], rr) + ddr[1], ytop = round(geog[i, "y"], rr) + ddr[2], lwd = 0.5, border = gray(0.6))
  
  # Select departement data
  depDat <- dat.Deps[which(dat.Deps$dep == geog[i, "dep"] & dat.Deps$date2 >= initDate), ]
  
  # Horizontal line for 0.5
 #  lines(c(round(geog[i, "x"], rr), round(geog[i, "x"], rr) + ddr[1]), rep(round(geog[i, "y"], rr) + ddr[2]/2, 2), lty = 1, col = gray(0.6), lwd = 0.5)
  
  # Draw curve
  if(geog[i, "dep"] == "75"){
    ylb <- TRUE
  }else{
    ylb <- FALSE
  }
  drawRec0(depDat, x = round(geog[i, "x"], rr), y = round(geog[i, "y"], rr), dxy = ddr, col = col452R, 
           ymin = ymin, ymax = ymax, 
           ylabels = ylb)

#    readline(prompt="Press [enter] to continue")

}


#drawRec(depDat, x = 5.73820184045573, y = 7.01837788404748, dxy = ddr, col = col452R)

minDay <- format(as.Date(initDate), "%d %b")
maxDay <- format(max(dat.Deps$date2), "%d %b")


# xP <- 1.34031283936975
# yP <- 15.0106959818622
# cexLeg <- 0.45
# text(x = xP, y = yP, adj = c(1, 0), labels = ymin, cex = 0.4)
# text(x = xP, y = yP + ddr[2], adj = c(1, 0.5), labels = ymax, cex = cexLeg)

text(x = c(xP, xP + ddr[1]), y = c(yP, yP), adj = c(0.5, 1.5), labels = c(minDay, maxDay), cex = cexLeg)

title("Absence de L452R, échelle logit")

  mtext("  @flodebarre
  Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
  Code : https://github.com/flodebarre/nouveauCriblage
  Idée carte : Les Decodeurs, Le Monde https://tinyurl.com/carteFRDecLM", side = 1, line = 1, cex = 0.6, col = gray(0.5), adj = 0)
  
cexLegend <- 0.55
#legend("topright", legend = c("Proportion L452R, < 50% le dernier jour", "≥ 50% le dernier jour"), cex = cexLegend, bty = "n", col = c(col452R, col452R.complement), lty = 1, pch = 16)
legend("topright", legend = c(paste0("Données tracées si au moins ", 100*thrp, "% des cas criblés
et au moins ", thrntot, " criblages sur la semaine. 
Itv confiance sur nb crib. moyen 7 derniers jours.

Attention : 
- les données publiques sont lissées, ce qui atténue le signal
- il y a de moins en moins de criblage dans les données publiques")), cex = cexLegend, bty = "n", adj = c(0, 0))
```

### E484K/Q

```{r}

thrp <- 0.1
thrntot <- 30

drawRec2 <- function(depDat, x, y, dxy, col = col484K, thr.p = thrp, thr.n = thrntot/7, colMaj = col452R.complement){
  # depDat: dataset for this departement
  # x: x position of the bottom left corner
  # y: y position of the bottom left corner
  # dxy: rectangle size c(dx, dy)
  # col: main color
  # thr.p: threshold to plot criblage data, minimum proportion of cases
  # thr.n: threshold in terms of number of tests done
  
  relTime <- as.numeric(depDat$time)/max(as.numeric(depDat$time))
  test0 <- depDat$nb_A0 + depDat$nb_B0
  test1 <- depDat$nb_A1 + depDat$nb_B1
  
  denom <- 7
  n <- (test1 + test0) / denom
  p <- test1 / (test1 + test0)
  
  scale.xy <- function(z, z1, z2){
    # z has to be between 0 and 1
    stopifnot(z >= 0 | z <= 1)
    z1 + (z2 - z1) * z
  }
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) & (n/(depDat$nb_pos/denom) >= thr.p) & (n >= thr.n)
  
  if(any(keepPts)){
      # Remove points for which the itv cannot be computed
  # and point with not enough criblage
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]
  
  # Color depends on whether main mutation
  if(pp[length(pp)] > 0.5){
    thecol <- colMaj
  }else{
      thecol <- col
  }

  lines(scale.xy(relTime[keepPts], x, x + dxy[1]), scale.xy(pp, y, y + dxy[2]), type = "o", col = thecol, pch = 16, cex = 0.2, lwd = 0.7)
  
  xx <- relTime[keepPts]
  
  polygon(x = scale.xy(c(xx, rev(xx), xx[1]), x, x + dxy[1]), y = scale.xy(c(sapply(pp + deltaItv, min, 1), 
                                                                             sapply(rev(pp - deltaItv), max, 0), 
                                                                             sapply((pp + deltaItv)[1], min, 1)), y, y + dxy[2]), border = NA, col = adjustcolor(thecol, alpha.f = 0.3))
  }
  
}
```

```{r figMapDepE484, fig.width = 7, fig.height = 9}

par(mar = rep(0.2, 4) + c(2, 0, 2, 0))
# Initialize plot with rect positions
plot(c(round(geog$x, rr), round(geog$x, rr) + ddr[1]), c(round(geog$y, rr), round(geog$y, rr) + ddr[2]), type = "n", asp = 1, axes = FALSE, xlab = "", ylab = "")

# Add titles of the plots
text(x = round(geog$x, rr) + ddr[1]/2, y = round(geog$y, rr) + ddr[2], labels = paste0(geog$shortName, "(", geog$dep, ")"), bg = "white", adj = c(0.5, -0.4), cex = 0.45)

for(i in seq_len(nrow(geog))){
  # Draw rectangle
  rect(xleft = round(geog[i, "x"], rr), ybottom = round(geog[i, "y"], rr), xright = round(geog[i, "x"], rr) + ddr[1], ytop = round(geog[i, "y"], rr) + ddr[2], lwd = 0.5, border = gray(0.6))
  
  # Select departement data
  depDat <- dat.Deps[which(dat.Deps$dep == geog[i, "dep"]), ]
  
  # Horizontal line for 0.5
  lines(c(round(geog[i, "x"], rr), round(geog[i, "x"], rr) + ddr[1]), rep(round(geog[i, "y"], rr) + ddr[2]/2, 2), lty = 1, col = gray(0.6), lwd = 0.5)
  
  # Draw curve
  drawRec2(depDat, x = round(geog[i, "x"], rr), y = round(geog[i, "y"], rr), dxy = ddr, col = col484K)

#    readline(prompt="Press [enter] to continue")

}


#drawRec(depDat, x = 5.73820184045573, y = 7.01837788404748, dxy = ddr, col = col452R)

minDay <- format(min(dat.Deps$date2), "%d %b")
maxDay <- format(max(dat.Deps$date2), "%d %b")


xP <- 1.34031283936975
yP <- 15.0106959818622
cexLeg <- 0.45
text(x = xP, y = yP, adj = c(1, 0), labels = "0% ", cex = 0.4)
text(x = xP, y = yP + ddr[2], adj = c(1, 0.5), labels = "100% ", cex = cexLeg)

text(x = c(xP, xP + ddr[1]), y = c(yP, yP), adj = c(0.5, 1.5), labels = c(minDay, maxDay), cex = cexLeg)

title("Proportion de E484K/Q")

  mtext("  @flodebarre
  Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
  Code : https://github.com/flodebarre/nouveauCriblage
  Idée carte : Les Decodeurs, Le Monde https://tinyurl.com/carteFRDecLM", side = 1, line = 1, cex = 0.6, col = gray(0.5), adj = 0)
  
cexLegend <- 0.6
legend("topright", legend = c("Proportion E484K/Q, < 50% le dernier jour", "≥ 50% le dernier jour"), cex = cexLegend, bty = "n", col = c(col484K, col452R.complement), lty = 1, pch = 16)
legend("topright", legend = c("", paste0("Données tracées si au moins ", 100*thrp, "% des cas criblés
et au moins ", thrntot, " criblages sur la semaine. 
Itv confiance sur nb crib. moyen 7 derniers jours.")), cex = cexLegend, bty = "n")
```


# Other

```{r}
dat <- dat.Deps[dat.Deps$departement == "Somme", ]
  plotNbCrib(dat)
  title("Somme")
  
    plotMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", "Somme"), ymax = ymax)

```
