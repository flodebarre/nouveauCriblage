---
title: "Mutations"
author: "FD"
output: 
  html_document: 
      code_folding: hide
      toc: TRUE
      toc_float: TRUE
      self_contained: no
editor_options:
  chunk_output_type: console
---

```{r, eval=FALSE}
rm(list = ls()) # I don't care what you think
for(i in dev.list()) dev.off()
setwd("scripts/")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Source of the data:  
<https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/>

# Initializations

```{r}
library(RColorBrewer)
colMut <- brewer.pal(n = 8, name = "Dark2")

col484K <- colMut[1]
col484Q <- colMut[2]
col452R <- colMut[3]
colTotCrib <- gray(0)#colMut[8]
colTot <- colMut[7]

col452R.complement <- "#b37570"
```

```{r}
unique.noNA <- function(x){
  unique(x[!is.na(x)])
}
```

# Load data 

## Test data

```{r}
URL_Deps <- "https://www.data.gouv.fr/fr/datasets/r/4d3e5a8b-9649-4c41-86ec-5420eb6b530c"
URL_Regions <- "https://www.data.gouv.fr/fr/datasets/r/5ff0cad6-f150-47ea-a4e0-57e354c1b2a4"
URL_France <- "https://www.data.gouv.fr/fr/datasets/r/848debc4-0e42-4e3b-a176-afc285ed5401"
```


```{r}
# Download files from repo
# Need to use extra option to follow the redirection
download.file(URL_France, 
              destfile="../data/muts_France.csv",
              method="curl",
              extra='-L')
download.file(URL_Regions, 
              destfile="../data/muts_Regions.csv",
              method="curl",
              extra='-L')
download.file(URL_Deps, 
              destfile="../data/muts_Deps.csv",
              method="curl",
              extra='-L')


dat.France <- read.csv("../data/muts_France.csv", sep = ";", stringsAsFactors = FALSE)
dat.Regions <- read.csv("../data/muts_Regions.csv", sep = ";", stringsAsFactors = FALSE)
dat.Deps <- read.csv("../data/muts_Deps.csv", sep = ";", stringsAsFactors = FALSE)

```


## Geographic data

### Regions 

```{r}
# Codes regions
URL <- "https://www.data.gouv.fr/en/datasets/r/34fc7b52-ef11-4ab0-bc16-e1aae5c942e7"
dataFile <- "../data/coderegions.csv"
download.file(URL, dataFile)
codesRegions <- read.csv(dataFile, sep = ",", stringsAsFactors = FALSE)

# Turn into dictionary
regs <- codesRegions$nom_region
names(regs) <- as.character(codesRegions$code_region)

# Add region name
dat.Regions$reg_name <- regs[as.character(dat.Regions$reg)]

unique(dat.Regions$reg_name)
unique(dat.Regions[which(is.na(dat.Regions$reg_name)), "reg"])


```


### Departments

```{r}
# Add name
deps <- read.csv("../data/departement2020.csv", stringsAsFactors = FALSE)
# Turn into dictionnary
dps <- deps$libelle
names(dps) <- as.character(deps$dep)


dat.Deps$departement <- dps[as.character(dat.Deps$dep)]

unique(dat.Deps$departement)

unique(dat.Deps[which(is.na(dat.Deps$departement)), "dep"])

# 977 Saint-Barthélemy, 978 Saint-Martin
```

## Clean data

```{r}
# Format date
dat.France$date1 <- as.Date(substring(dat.France$semaine, 1, 10))
dat.France$date2 <- as.Date(substring(dat.France$semaine, 12, 21))
# Rewrite time as days since beginning of the data
dat.France$time <- dat.France$date2 - min(dat.France$date2)
```


```{r}
# Format date
dat.Regions$date1 <- as.Date(substring(dat.Regions$semaine, 1, 10))
dat.Regions$date2 <- as.Date(substring(dat.Regions$semaine, 12, 21))
# Rewrite time as days since beginning of the data
dat.Regions$time <- dat.Regions$date2 - min(dat.Regions$date2)
```


```{r}
# Format date
dat.Deps$date1 <- as.Date(substring(dat.Deps$semaine, 1, 10))
dat.Deps$date2 <- as.Date(substring(dat.Deps$semaine, 12, 21))
# Rewrite time as days since beginning of the data
dat.Deps$time <- dat.Deps$date2 - min(dat.Deps$date2)
```


## Consistency checks 

```{r}

testDat <- function(dat){
  # Check number of genotypied tests
  testTotA <- sum(dat$nb_crib != (dat$nb_A0+ dat$nb_A1))
  testTotB <- sum(dat$nb_crib != (dat$nb_B0+ dat$nb_B1))
  testTotC <- sum(dat$nb_crib != (dat$nb_C0+ dat$nb_C1))
  
  # Test proportions of positive genotyping tests
  # nb of digits in the result varies across datasets
  if(all(dat$tx_A1 == round(dat$tx_A1, 1))){nDigits <- 1}else{nDigits <- 2}
  testA <- sum(dat$tx_A1 != round(dat$nb_A1 / (dat$nb_A0 + dat$nb_A1)*100, nDigits), na.rm = TRUE)
  testB <- sum(dat$tx_B1 != round(dat$nb_B1 / (dat$nb_B0 + dat$nb_B1)*100, nDigits), na.rm = TRUE)
  testC <- sum(dat$tx_C1 != round(dat$nb_C1 / (dat$nb_C0 + dat$nb_C1)*100, nDigits), na.rm = TRUE)
  
  testCrib <- sum(round(dat$tx_crib / 100 * dat$nb_pos) != round(dat$nb_crib))
  
  # Return outcome
  c(nrow(dat), testCrib, testTotA, testTotB, testTotB, testA, testB, testC)
}

testDat(dat.France)
testDat(dat.Regions)
testDat(dat.Deps)
```

# Plots 

## Numbers of tests

```{r}
plotNbCrib <- function(dat, quot = TRUE, addLegend = TRUE, tp = "l", lwd = 1.5){
  # dat: dataset to be plotted
  # quot: boolean to decide whether to plot the daily values (averaged over 7 days) [TRUE], or the sum over the last 7 days [FALSE]
  # addLegend: whether to add plot legend
  # tp: line type
  if(quot){denom <- 7}else{denom <- 1}
  par(las = 1)
  par(mar = c(2, 4, 3, 4))
  plot(as.Date(dat$date2), dat$nb_pos / denom, ylim = c(0, 1.05*max(dat$nb_pos / denom, na.rm = TRUE)), yaxs = "i", 
       type = tp, pch = 16, col = colTot, 
       lwd = lwd, 
       frame.plot = FALSE, 
       xlab = "", ylab = "")
  
  lines(as.Date(dat$date2), dat$nb_crib / denom, type = tp, pch = 16, col = colTotCrib)
  
  if(addLegend){
    legend(x = "topright", legend = c("Nb tests positifs", "Nb tests criblés", "Nb tests interprétables E484K", "Nb tests interprétables E484Q", "Nb tests interprétables L452R"), 
         col = c(colTot, colTotCrib, col484K, col484Q, col452R), 
         #pch = 16, 
         lty = 1, box.col = gray(0, 0), bty = "n", 
         lwd = lwd)
  }
  
  lines(as.Date(dat$date2), (dat$nb_A0 + dat$nb_A1) / denom, type = tp, pch = 16, col = col484K, lwd = lwd)
  lines(as.Date(dat$date2), (dat$nb_B0 + dat$nb_B1) / denom, type = tp, pch = 16, col = col484Q, lwd = lwd)
  lines(as.Date(dat$date2), (dat$nb_C0 + dat$nb_C1) / denom, type = tp, pch = 16, col = col452R, lwd = lwd)
  
  axis(4)
}
```


```{r}
plotNbCrib(dat.France)
title(main = "France")

for(reg in unique.noNA(dat.Regions$reg_name)){
  dat <- dat.Regions[dat.Regions$reg_name == reg, ]
  plotNbCrib(dat, addLegend = FALSE)
  title(main = reg)
}


# Function to plot one region
plotReg <- function(reg){
  dat <- dat.Regions[dat.Regions$reg_name == reg, ]
  plotNbCrib(dat, addLegend = FALSE)
  title(main = reg)
}

#[1] "Auvergne-Rhône-Alpes"       "Hauts-de-France"            "Provence-Alpes-Côte d'Azur" "Grand Est"                 
# [5] "Occitanie"                  "Normandie"                  "Nouvelle-Aquitaine"         "Centre-Val de Loire"       
# [9] "Corse"                      "Bourgogne-Franche-Comté"    "Bretagne"                   "Pays de la Loire"          
#[13] "Île-de-France"              "Guadeloupe"                 "Martinique"                 "Guyane"                 
#[17] "La Réunion"                 "Mayotte" 
```

```{r figRegionsMapNBCriblage, fig.width=10, fig.height=10}

layout(matrix(1:15, ncol = 3, byrow = TRUE))

# 1 Plot legend
par(mar = c(0, 0, 0, 0))
plot(0, 0, xlab = "", ylab = "", type = "n", axes = FALSE, xlim = c(-0.2, 1), ylim = c(-1, 0.5))
legend(x = 0, y = 0, legend = c("Nb tests positifs", "Nb tests criblés", "Nb tests interprétables E484K", "Nb tests interprétables E484Q", "Nb tests interprétables L452R"), 
         col = c(colTot, colTotCrib, col484K, col484Q, col452R), 
         #pch = 16, 
         lty = 1, box.col = gray(0, 0), bty = "n", cex = 1)

# 2 HDF
plotReg("Hauts-de-France")

# 3 Plot credits
par(mar = c(0, 0, 0, 0))
plot(0, 0, xlab = "", ylab = "", type = "n", axes = FALSE, xlim = c(-0.1, 1), ylim = c(-1, 1))
text(0, 0, "@flodebarre 

Data:
https://www.data.gouv.fr/fr/datasets/
donnees-de-laboratoires-pour-le-
depistage-indicateurs-sur-les-mutations/

Code: https://github.com/flodebarre/
nouveauCriblage/blob/main/scripts/mutations.Rmd
", adj = 0, cex = 0.8, family = "mono")

# 4 NOR
plotReg("Normandie")

# 5 IDF
plotReg("Île-de-France")

# 6 GE
plotReg("Grand Est")

# 7 BRE
plotReg("Bretagne")

# 8 CVL
plotReg("Centre-Val de Loire")

# 9 BFC
plotReg("Bourgogne-Franche-Comté")

# 10 PDL
plotReg("Pays de la Loire")

# 11 ARA
plotReg("Auvergne-Rhône-Alpes")

# 12 PACA
plotReg("Provence-Alpes-Côte d'Azur")

# 13 NAQ
plotReg("Nouvelle-Aquitaine")

# 14 OCC
plotReg("Occitanie")

# 15 COR
plotReg("Corse")
#[1] "Auvergne-Rhône-Alpes"       "Hauts-de-France"            "Provence-Alpes-Côte d'Azur" "Grand Est"                 
# [5] "Occitanie"                  "Normandie"                  "Nouvelle-Aquitaine"         "Centre-Val de Loire"       
# [9] "Corse"                      "Bourgogne-Franche-Comté"    "Bretagne"                   "Pays de la Loire"  

```


## Proportions / Nb tests

```{r}
plotMut <- function(time, test0, test1, col, thetit, ymax = 1, quot = TRUE){
  # dat: dataset to be plotted
  # quot: boolean to decide whether to plot the daily values (averaged over 7 days) [TRUE], or the sum over the last 7 days [FALSE]
  
  if(quot){denom <- 7}else{denom <- 1}
  n <- (test1 + test0) / denom
  p <- test1 / (test1 + test0)
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) 
  # Remove points for which the itv cannot be computed
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]

  par(mar = c(5, 4, 4, 4))
  par(las = 1)
  plot(as.Date(time), p, ylim = c(0, ymax), frame.plot = FALSE, 
     xlab = "", ylab = "p", yaxs = "i", xaxs = "i", 
     type = "l", col = col, pch = 16)
mtext("  Parmi les n(t) tests interprétables recherchant la mutation
  Intervalle de confiance binomial sur ce nombre de tests n(t)", side = 3, cex = 0.6, adj = 0, line = -1)
mtext("date", line = 2, side = 1)  
  axis(4)
  xx <- base::as.Date(time)[keepPts]
  # Add graduation
  for(i in seq(0, 1, by = 0.1)){
    abline(h = i, col = gray(0.9), lwd = 1.1)
  }
  for(i in seq(0.05, 0.95, by = 0.1)){
    abline(h = i, col = gray(0.9), lwd = 0.8)
  }
  
  polygon(x = c(xx, rev(xx), xx[1]), y = c(pp + deltaItv, rev(pp - deltaItv), (pp + deltaItv)[1]), border = NA, col = adjustcolor(col, alpha.f = 0.3))
  
  mtext("Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
Code : https://github.com/flodebarre/nouveauCriblage", side = 1, line = 3.5, cex = 0.7, col = gray(0.5), adj = 0)

  title(main = thetit)
  print(p[length(p)])
}
```



```{r}
plotCaseMut <- function(time, test0, test1, col, thetit, ymax = 1, quot = TRUE){
  # dat: dataset to be plotted
  # quot: boolean to decide whether to plot the daily values (averaged over 7 days) [TRUE], or the sum over the last 7 days [FALSE]
  
  if(quot){denom <- 7}else{denom <- 1}
  n <- (test1 + test0) / denom
  p <- test1 / (test1 + test0)
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) 
  # Remove points for which the itv cannot be computed
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]
  nn <- n[keepPts]

  par(mar = c(5, 4, 4, 4))
  par(las = 1)
  ymax <- 1.05 * max(pp*nn + nn*deltaItv, na.rm = TRUE)
  plot(as.Date(time), p * n, ylim = c(0, ymax), frame.plot = FALSE, 
     xlab = "", ylab = "n", yaxs = "i", xaxs = "i", 
     type = "o", col = col, pch = 16)
mtext("  Parmi les n(t) tests interprétables recherchant la mutation
  Intervalle de confiance binomial sur ce nombre de tests n(t)", side = 3, cex = 0.6, adj = 0, line = -1)
mtext("date", line = 2, side = 1) 
  axis(2, at = seq(0, 1, by = 0.1))
  axis(4, at = seq(0, 1, by = 0.1))
  xx <- base::as.Date(time)[keepPts]
  polygon(x = c(xx, rev(xx), xx[1]), y = c(nn*pp + nn*deltaItv, rev(nn*pp - nn*deltaItv), (nn*pp + nn*deltaItv)[1]), border = NA, col = adjustcolor(col, alpha.f = 0.3))
  
  mtext("Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
Code : https://github.com/flodebarre/nouveauCriblage", side = 1, line = 3.5, cex = 0.7, col = gray(0.5), adj = 0)

  title(main = thetit)
}
```


### France 

```{r}
plotMut(dat.France$date2, dat.France$nb_A0, dat.France$nb_A1, col = col484K, thetit = "Proportion of cases with \nE484K, France", ymax = 0.3)
plotMut(dat.France$date2, dat.France$nb_B0, dat.France$nb_B1, col = col484Q, thetit = "Proportion of cases with \nE484Q, France", ymax = 0.3)
plotMut(dat.France$date2, dat.France$nb_C0, dat.France$nb_C1, col = col452R, thetit = "L452R, France")
```

```{r}
plotCaseMut(dat.France$date2, dat.France$nb_A0, dat.France$nb_A1, col = col484K, thetit = "E484K, France")
plotCaseMut(dat.France$date2, dat.France$nb_B0, dat.France$nb_B1, col = col484Q, thetit = "E484Q, France")
plotCaseMut(dat.France$date2, dat.France$nb_C0, dat.France$nb_C1, col = col452R, thetit = "L452R, France")
```


### Regions 

```{r eval = FALSE}
for(reg in unique.noNA(dat.Regions$reg_name)){
  dat <- dat.Regions[dat.Regions$reg_name == reg, ]
  plotMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", reg), ymax = 1)
}

```

### Departements

```{r}
ymax <- max(1, 1.05*max(dat.Deps$nb_C1 / (dat.Deps$nb_C1 + dat.Deps$nb_C0), na.rm = TRUE))
```

```{r eval = FALSE}
for(dep in sort(unique.noNA(dat.Deps$departement))){
  dat <- dat.Deps[dat.Deps$departement == dep, ]
  plotMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", dep), ymax = ymax)
}
```

```{r eval = FALSE}
ymax <- max(1, 1.05*max(dat.Deps$nb_B1 / (dat.Deps$nb_B1 + dat.Deps$nb_B0), na.rm = TRUE))
for(dep in sort(unique.noNA(dat.Deps$departement))){
  dat <- dat.Deps[dat.Deps$departement == dep, ]
  plotMut(time = dat$date2, test0 = dat$nb_B0, test1 = dat$nb_B1, col = col484Q, thetit = paste0("E484Q, ", dep), ymax = ymax)
}
```

```{r}
dep <- "Alpes-Maritimes"
dat <- dat.Deps[dat.Deps$departement == dep, ]
  plotCaseMut(time = dat$date2, test0 = dat$nb_B0, test1 = dat$nb_B1, col = col484Q, thetit = paste0("E484Q, ", dep))
  plotCaseMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", dep))
  plotMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", dep))
  plotCaseMut(time = dat$date2, test0 = dat$nb_A0, test1 = dat$nb_A1, col = col484K, thetit = paste0("E484K, ", dep))
```

## Geographic

### L452R 

Source idea map: [Le Monde map](https://www.lemonde.fr/les-decodeurs/article/2020/05/05/coronavirus-age-mortalite-departements-pays-suivez-l-evolution-de-l-epidemie-en-cartes-et-graphiques_6038751_4355770.html) [| archived](https://archive.is/eJ68m)

```{r}
thrp <- 0.1
thrntot <- 30

drawRec <- function(depDat, x, y, dxy, col = col452R, thr.p = thrp, thr.n = thrntot/7, colMaj = col452R.complement){
  # depDat: dataset for this departement
  # x: x position of the bottom left corner
  # y: y position of the bottom left corner
  # dxy: rectangle size c(dx, dy)
  # col: main color
  # thr.p: threshold to plot criblage data, minimum proportion of cases
  # thr.n: threshold in terms of number of tests done
  
  relTime <- as.numeric(depDat$time)/max(as.numeric(depDat$time))
  test0 <- depDat$nb_C0
  test1 <- depDat$nb_C1
  
  denom <- 7
  n <- (test1 + test0) / denom
  p <- test1 / (test1 + test0)
  
  scale.xy <- function(z, z1, z2, zmax = 1){
    # z has to be between 0 and 1
    stopifnot(z >= 0 | z <= 1)
    z1 + (z2 - z1) * z/zmax
  }
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) & (depDat$tx_crib/100 >= thr.p) & (n >= thr.n)
  
  if(any(keepPts)){
      # Remove points for which the itv cannot be computed
  # and point with not enough criblage
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]
  
  # Color depends on whether main mutation
  if(pp[length(pp)] > 0.5){
    thecol <- colMaj
  }else{
      thecol <- col
  }

  lines(scale.xy(relTime[keepPts], x, x + dxy[1]), scale.xy(pp, y, y + dxy[2]), type = "o", col = thecol, pch = 16, cex = 0.2, lwd = 0.7)
  
  xx <- relTime[keepPts]
  
  polygon(x = scale.xy(c(xx, rev(xx), xx[1]), x, x + dxy[1]), y = scale.xy(c(sapply(pp + deltaItv, min, 1), 
                                                                             sapply(rev(pp - deltaItv), max, 0), 
                                                                             sapply((pp + deltaItv)[1], min, 1)), y, y + dxy[2]), border = NA, col = adjustcolor(thecol, alpha.f = 0.3))
  }
  
}
```

```{r figMapDepL452R, fig.width = 7, fig.height = 9}
geog <- read.csv("../data/position_deps.csv", header = FALSE)
names(geog) <- c("x", "y", "dep", "shortName")
rr <- 2 # Rounding factor

d1 <- c(5.367367157581877, 1.008996513422371)
d2 <- c(6.203498009030808, 1.7266142092327605)
dd <- d2 - d1
ddr <- round(dd,rr)

par(mar = rep(0.2, 4) + c(2, 0, 2, 0))
# Initialize plot with rect positions
plot(c(round(geog$x, rr), round(geog$x, rr) + ddr[1]), c(round(geog$y, rr), round(geog$y, rr) + ddr[2]), type = "n", asp = 1, axes = FALSE, xlab = "", ylab = "")

# Add titles of the plots
text(x = round(geog$x, rr) + ddr[1]/2, y = round(geog$y, rr) + ddr[2], labels = paste0(geog$shortName, "(", geog$dep, ")"), bg = "white", adj = c(0.5, -0.4), cex = 0.45)

for(i in seq_len(nrow(geog))){
  # Draw rectangle
  rect(xleft = round(geog[i, "x"], rr), ybottom = round(geog[i, "y"], rr), xright = round(geog[i, "x"], rr) + ddr[1], ytop = round(geog[i, "y"], rr) + ddr[2], lwd = 0.5, border = gray(0.6))
  
  # Select departement data
  depDat <- dat.Deps[which(dat.Deps$dep == geog[i, "dep"]), ]
  
  # Horizontal line for 0.5
  lines(c(round(geog[i, "x"], rr), round(geog[i, "x"], rr) + ddr[1]), rep(round(geog[i, "y"], rr) + ddr[2]/2, 2), lty = 1, col = gray(0.6), lwd = 0.5)
  
  # Draw curve
  drawRec(depDat, x = round(geog[i, "x"], rr), y = round(geog[i, "y"], rr), dxy = ddr, col = col452R)

#    readline(prompt="Press [enter] to continue")

}


#drawRec(depDat, x = 5.73820184045573, y = 7.01837788404748, dxy = ddr, col = col452R)

minDay <- format(min(dat.Deps$date2), "%d %b")
maxDay <- format(max(dat.Deps$date2), "%d %b")


xP <- 1.34031283936975
yP <- 15.0106959818622
cexLeg <- 0.45
text(x = xP, y = yP, adj = c(1, 0), labels = "0% ", cex = 0.4)
text(x = xP, y = yP + ddr[2], adj = c(1, 0.5), labels = "100% ", cex = cexLeg)

text(x = c(xP, xP + ddr[1]), y = c(yP, yP), adj = c(0.5, 1.5), labels = c(minDay, maxDay), cex = cexLeg)

title("Proportion de L452R")

  mtext("  @flodebarre
  Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
  Code : https://github.com/flodebarre/nouveauCriblage
  Idée carte : Les Decodeurs, Le Monde https://tinyurl.com/carteFRDecLM", side = 1, line = 1, cex = 0.6, col = gray(0.5), adj = 0)
  
cexLegend <- 0.6
legend("topright", legend = c("Proportion L452R, < 50% le dernier jour", "≥ 50% le dernier jour"), cex = cexLegend, bty = "n", col = c(col452R, col452R.complement), lty = 1, pch = 16)
legend("topright", legend = c("", paste0("Données tracées si au moins ", 100*thrp, "% des cas criblés
et au moins ", thrntot, " criblages sur la semaine. 
Itv confiance sur nb crib. moyen 7 derniers jours.")), cex = cexLegend, bty = "n")
```

### E484K/Q

```{r}

thrp <- 0.1
thrntot <- 30

drawRec2 <- function(depDat, x, y, dxy, col = col484K, thr.p = thrp, thr.n = thrntot/7, colMaj = col452R.complement){
  # depDat: dataset for this departement
  # x: x position of the bottom left corner
  # y: y position of the bottom left corner
  # dxy: rectangle size c(dx, dy)
  # col: main color
  # thr.p: threshold to plot criblage data, minimum proportion of cases
  # thr.n: threshold in terms of number of tests done
  
  relTime <- as.numeric(depDat$time)/max(as.numeric(depDat$time))
  test0 <- depDat$nb_A0 + depDat$nb_B0
  test1 <- depDat$nb_A1 + depDat$nb_B1
  
  denom <- 7
  n <- (test1 + test0) / denom
  p <- test1 / (test1 + test0)
  
  scale.xy <- function(z, z1, z2){
    # z has to be between 0 and 1
    stopifnot(z >= 0 | z <= 1)
    z1 + (z2 - z1) * z
  }
  
  # Computation of the confidence interval
  deltaItv <- 1.96 * sqrt(p * (1-p) / n)
  keepPts <- !is.na(deltaItv) & (n/(depDat$nb_pos/denom) >= thr.p) & (n >= thr.n)
  
  if(any(keepPts)){
      # Remove points for which the itv cannot be computed
  # and point with not enough criblage
  deltaItv <- deltaItv[keepPts]
  pp <- p[keepPts]
  
  # Color depends on whether main mutation
  if(pp[length(pp)] > 0.5){
    thecol <- colMaj
  }else{
      thecol <- col
  }

  lines(scale.xy(relTime[keepPts], x, x + dxy[1]), scale.xy(pp, y, y + dxy[2]), type = "o", col = thecol, pch = 16, cex = 0.2, lwd = 0.7)
  
  xx <- relTime[keepPts]
  
  polygon(x = scale.xy(c(xx, rev(xx), xx[1]), x, x + dxy[1]), y = scale.xy(c(sapply(pp + deltaItv, min, 1), 
                                                                             sapply(rev(pp - deltaItv), max, 0), 
                                                                             sapply((pp + deltaItv)[1], min, 1)), y, y + dxy[2]), border = NA, col = adjustcolor(thecol, alpha.f = 0.3))
  }
  
}
```

```{r figMapDepE484, fig.width = 7, fig.height = 9}

par(mar = rep(0.2, 4) + c(2, 0, 2, 0))
# Initialize plot with rect positions
plot(c(round(geog$x, rr), round(geog$x, rr) + ddr[1]), c(round(geog$y, rr), round(geog$y, rr) + ddr[2]), type = "n", asp = 1, axes = FALSE, xlab = "", ylab = "")

# Add titles of the plots
text(x = round(geog$x, rr) + ddr[1]/2, y = round(geog$y, rr) + ddr[2], labels = paste0(geog$shortName, "(", geog$dep, ")"), bg = "white", adj = c(0.5, -0.4), cex = 0.45)

for(i in seq_len(nrow(geog))){
  # Draw rectangle
  rect(xleft = round(geog[i, "x"], rr), ybottom = round(geog[i, "y"], rr), xright = round(geog[i, "x"], rr) + ddr[1], ytop = round(geog[i, "y"], rr) + ddr[2], lwd = 0.5, border = gray(0.6))
  
  # Select departement data
  depDat <- dat.Deps[which(dat.Deps$dep == geog[i, "dep"]), ]
  
  # Horizontal line for 0.5
  lines(c(round(geog[i, "x"], rr), round(geog[i, "x"], rr) + ddr[1]), rep(round(geog[i, "y"], rr) + ddr[2]/2, 2), lty = 1, col = gray(0.6), lwd = 0.5)
  
  # Draw curve
  drawRec2(depDat, x = round(geog[i, "x"], rr), y = round(geog[i, "y"], rr), dxy = ddr, col = col484K)

#    readline(prompt="Press [enter] to continue")

}


#drawRec(depDat, x = 5.73820184045573, y = 7.01837788404748, dxy = ddr, col = col452R)

minDay <- format(min(dat.Deps$date2), "%d %b")
maxDay <- format(max(dat.Deps$date2), "%d %b")


xP <- 1.34031283936975
yP <- 15.0106959818622
cexLeg <- 0.45
text(x = xP, y = yP, adj = c(1, 0), labels = "0% ", cex = 0.4)
text(x = xP, y = yP + ddr[2], adj = c(1, 0.5), labels = "100% ", cex = cexLeg)

text(x = c(xP, xP + ddr[1]), y = c(yP, yP), adj = c(0.5, 1.5), labels = c(minDay, maxDay), cex = cexLeg)

title("Proportion de E484K/Q")

  mtext("  @flodebarre
  Données : https://www.data.gouv.fr/fr/datasets/donnees-de-laboratoires-pour-le-depistage-indicateurs-sur-les-mutations/
  Code : https://github.com/flodebarre/nouveauCriblage
  Idée carte : Les Decodeurs, Le Monde https://tinyurl.com/carteFRDecLM", side = 1, line = 1, cex = 0.6, col = gray(0.5), adj = 0)
  
cexLegend <- 0.6
legend("topright", legend = c("Proportion E484K/Q, < 50% le dernier jour", "≥ 50% le dernier jour"), cex = cexLegend, bty = "n", col = c(col484K, col452R.complement), lty = 1, pch = 16)
legend("topright", legend = c("", paste0("Données tracées si au moins ", 100*thrp, "% des cas criblés
et au moins ", thrntot, " criblages sur la semaine. 
Itv confiance sur nb crib. moyen 7 derniers jours.")), cex = cexLegend, bty = "n")
```


# Other

```{r}
dat <- dat.Deps[dat.Deps$departement == "Somme", ]
  plotNbCrib(dat)
  title("Somme")
  
    plotMut(time = dat$date2, test0 = dat$nb_C0, test1 = dat$nb_C1, col = col452R, thetit = paste0("L452R, ", "Somme"), ymax = ymax)

```
